<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>调用栈堆</title>
      <link href="/2018/12/13/diao-yong-zhan-dui/"/>
      <url>/2018/12/13/diao-yong-zhan-dui/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h4 id="栈-stack-和堆-heap"><a href="#栈-stack-和堆-heap" class="headerlink" title="栈 (stack) 和堆 (heap)"></a>栈 (stack) 和堆 (heap)</h4><p>一般来说，栈内存中存放的是存储对象的地址，而堆内存中存放的是存储对象的具体内容。</p><p>栈是有结构的，每个区块按照一定次序存放（后进先出），栈中主要存放一些基本类型的变量和对象的引用，存在栈中的数据大小与生存期必须是确定的。可以明确知道每个区块的大小，因此，栈的寻址速度要快于堆。</p><p>堆是没有结构的，数据可以任意存放。堆用于复杂数据类型（引用类型）分配空间，例如数组对象、object对象。<br>首先科普下基本类型和引用类型</p><blockquote><ul><li>基本类型：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）<br><span style="color:red;">关于Symbol（es6引入）特殊处理</span></li><li>引用类型：（object) =&gt; Array, function, data, RegExp<br>当我们需要访问引用类型（如对象，数组，函数等）的值时，首先从栈中获得该对象的地址指针，然后再从堆内存中取得所需的数据。</li></ul></blockquote><p>基本类型都是保存在栈当中，引用类型都是保存在堆当中</p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token string">'aaa'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//为a分配栈内存：a:'aaa'</span><span class="token keyword">let</span> copy_a <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//基本类型直接访问值，为copy_a新分配栈内存：copy_a = 'aaa'</span>a <span class="token operator">=</span> <span class="token string">'bbb'</span> <span class="token comment" spellcheck="true">//栈内存中:a:'bbb'。a的值为'bbb',而copy_a的值仍然是"aaa"</span>copy_a <span class="token operator">=</span> <span class="token number">1</span>  <span class="token comment" spellcheck="true">//栈内存中:copy_a:1。copy_a的值为1,而a的值仍然是"bbb"</span><span class="token comment" spellcheck="true">// let a = 'ccc' //报错</span><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token punctuation">{</span>b<span class="token punctuation">:</span><span class="token string">'bbb'</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//为b分配栈内存访问地址:b,堆内存中存对象值：{b:'bbb'}</span><span class="token keyword">var</span> copy_b <span class="token operator">=</span> b <span class="token comment" spellcheck="true">// 为copy_b分配栈内存访问地址:copy_b,引用了堆内存的值{b:'bbb'}</span>copy_b<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token string">'b'</span> <span class="token comment" spellcheck="true">// 通过copy_b访问(修改)堆内存的变量,这时候堆内存中对象值为:{b:"b"},</span> <span class="token comment" spellcheck="true">//由于b和copy_b引用的是堆内存中同一个对象值，所以这时候打印都是{b:"b"}</span>copy_b <span class="token operator">=</span> <span class="token punctuation">{</span>b<span class="token punctuation">:</span><span class="token string">'a'</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 因为改的是整个对象，这里会在堆内存中创建一个新的对象值:{b:"a"},</span><span class="token comment" spellcheck="true">//而现在的copy_b引用的是这个对象，所以这里打印的b依旧是{b:"b"},</span><span class="token comment" spellcheck="true">//而copy_b是{b:"a"}(两者在内存中引用的是不同对象了)。</span></code></pre><p>由于<code>const</code>定义的基本类型不能改变，但是定义的对象是可以通过修改对象属性等方法来改变的。因此当我们定义一个<code>const</code>对象的时候，我们说的常量其实是指针，就是<code>const</code>对象对应的堆内存指向是不变的，但是堆内存中的数据本身的大小或者属性是可变的。而对于<code>const</code>定义的基础变量而言，这个值就相当于<code>const</code>对象的指针，是不可变的。</p><p>既然知道了<code>const</code>在内存中的存储，那么<code>const</code>、<code>let</code>定义的变量不能二次定义的流程也就比较容易猜出来了，每次使用<code>const</code>或者<code>let</code>去初始化一个变量的时候，会首先遍历当前的内存栈，看看有没有重名变量，有的话就返回错误。</p><h2 id="那么问题来了"><a href="#那么问题来了" class="headerlink" title="那么问题来了"></a>那么问题来了</h2><p>new大家都知道，根据构造函数生成新实例，这个时候生成的是对象，而不是基本类型。<br>再看一个例子</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">'123'</span><span class="token punctuation">)</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token string">'123'</span><span class="token punctuation">)</span><span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token string">'123'</span><span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">'123'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token operator">==</span>b<span class="token punctuation">,</span> a<span class="token operator">===</span>b<span class="token punctuation">,</span> b<span class="token operator">==</span>c<span class="token punctuation">,</span> b<span class="token operator">===</span>c<span class="token punctuation">,</span> a<span class="token operator">==</span>c<span class="token punctuation">,</span> a<span class="token operator">===</span>c<span class="token punctuation">,</span> a<span class="token operator">==</span>d<span class="token punctuation">,</span> a<span class="token operator">===</span>d<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// true false true true true false false false</span></code></pre><p>很明显，如果<code>a</code>，<code>d</code>是存储在栈内存中的话，两者应该是明显相等的，就像<code>null === null</code>是true一样，但结果两者并不相等，说明两者都是存储在堆内存中的，指针指向不一致。</p><p>说到这里，再去想一想我们常说的值类型和引用类型其实说的就是栈内存变量和堆内存变量，再想想值传递和引用传递、深拷贝和浅拷贝，都是围绕堆栈内存展开的，一个是处理值，一个是处理指针，本篇文章不做阐述。</p><h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><p>既然我们已经初步了解了栈 (stack) 和堆 (heap)，那么可以思考下我们写的代码是怎么运行的呢？</p><p>首先我们以一段简单代码为示例，来看一看到底什么是调用栈，它是一个怎么样的运行机制</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> num <span class="token operator">*</span> num<span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">a</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token operator">*</span> num<span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">b</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>开始分析代码</p><ol><li><code>console.log(b(2))</code> 执行，形成一个栈帧，调用<code>b</code>函数，再形成另一个栈帧。</li><li>新的栈帧压在上一个栈帧之上，继续执行代码，<code>b</code>函数中又调用了<code>a</code>函数，形成了另一个栈帧压在旧栈帧之上，像叠罗汉一样，然后执行<code>a</code>。</li><li>当执行完<code>a</code>，返回<code>4</code>给<code>b</code>函数，<code>a</code>函数就被推出调用栈，<code>b</code>函数继续执行，返回<code>8</code>给<code>console.log</code>,<code>b</code>函数被推出调用栈,<code>console.log</code>输出结果，最后<code>console.log</code>也被推出调用栈,至此，该段程序执行结束。</li></ol><p>同步执行了解清楚，那异步函数呢，如<code>setTimeout</code></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> num <span class="token operator">*</span> num<span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">a</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token operator">*</span> num<span class="token punctuation">}</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">b</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">5000</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//1</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">b</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//8</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">b</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">3000</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//27</span></code></pre><p>首先我们要理解一下 <strong>Event Loop</strong>。<br>js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码…，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。</p><ol><li>结合前面的分析当代码运行到第一个<code>setTimeout</code>的时候，<code>setTimeout</code>是一个异步函数，将这个事件挂起，插入任务队列</li><li>继续执行<code>console.log(b(2))</code>,打印<code>8</code>，</li><li>再挂起一个<code>setTimeout</code>，插入任务队列，主线程闲置</li></ol><p>到此我们要去查找队列中的任务了，是哪个先出。</p><p>“任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。但是，由于存在”定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。</p><p>所以上述代码执行结果为8，27，1。</p><p>知道了这些我们就能很好的理解异步任务了</p><h2 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h2><p>异步任务之间并不相同，他们的执行优先级也有区别。不同的异步任务被分为两类：<br><strong>微任务（micro task）</strong></p><ol><li>new Promise() </li><li>new MutaionObserver()</li></ol><p><strong>宏任务（macro task）</strong></p><ol><li>setInterval()</li><li>setTimeout()</li></ol><p>再参考一个栗子</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//结果为:2 3 1</span></code></pre><p>前面我们说过，在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。</p><p>然而，根据这个异步事件的类型，这个事件实际上会被分配到对应的宏任务队列或者微任务队列中去。并且在当前执行栈为空的时候，主线程会查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的回调加入当前执行栈；如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈…如此反复，进入循环。</p><p>我们只需记住当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。</p><p>最后我们来讲讲垃圾回收</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>JavaScript垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是时时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。</p><p>首先理解下什么叫不再使用的变量？每个变量都有生命周期，全局变量的生命周期直至浏览器卸载页面才会结束。局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，然后再函数中使用这些变量，直至函数结束（闭包除外，同时在这不阐述闭包）。一旦函数结束，就释放局部变量占用的内存。</p><p>在这个大环境下其实我们不需要太过关注js的垃圾回收机制（个人观点），当然要注意平时培养良好的代码习惯，对这方面有执念的同学自行google，度娘。</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>不忘初心，写给远方的自己</title>
      <link href="/2018/12/10/bu-wang-chu-xin-xie-gei-yuan-fang-de-zi-ji/"/>
      <url>/2018/12/10/bu-wang-chu-xin-xie-gei-yuan-fang-de-zi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>初雪刚下，银装素裹的杭州显得格外的美丽，似乎连冷冽的寒风都显得没那么刺骨了。早在14年的时候就想好好写点技术文章，结果到15年底才开始写些东西。虽然以前写的东西比较稚嫩、片面、基础，还有些辣眼睛，但那毕竟是自己的<a href="http://bobo.missql.com/" target="_blank" rel="noopener">知识累积</a>，还是要放出来见见人。</p><p>这个知识累积是搭建在朋友的服务器和域名下，后来因为他的一些操作，导致服务器被攻击云云⋯⋯，甚是蛋疼，后来修复好了之后总有bug，就没有继续写下去了（反正当时写的也不好）。就另起了一个博客，搭建在自己的服务器和域名下（自己的东西就是放心），就是现在这个博客了，基于了<a href="https://blinkfox.github.io/" target="_blank" rel="noopener">https://blinkfox.github.io/</a>,在此感谢。</p><h2 id="重新出发"><a href="#重新出发" class="headerlink" title="重新出发"></a>重新出发</h2><p>度过了浮躁的时期，慢慢的沉淀自己，有些后知后觉，开启新的篇章，回忆过去，取其精华，去其糟粕，回归初心。朋友都说，写博客这个好习惯怎么能够停止呢，快拿起你的烂笔头，这是核心竞争力呀⋯⋯巴拉巴拉。颇有道理，可是我该怎么开始写呢。</p><p>都说是沉淀了，是不是应该做些总结，可是现在各种博客、csdn、简书、掘金不都写的挺好的么，看看他们的文章，收藏收藏，实践实践不就行了么（停下写博客后基本都这样做，一部分原因是工作太忙，一部分原因是文笔不行，一部分原因是技术没有真正的沉淀下来，还有一部分原因是懒~），虽然站在巨人的肩膀上是件很舒服的事情，但是那毕竟还是别人的东西，可能这就是无法良好的阅读源码的原因了吧。</p><p>那么接下来就到立flag的时间了</p><h2 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h2><hr><p>【进阶 1 期】 调用堆栈<br><!-- 【进阶 2 期】 作用域闭包【进阶 3 期】 this 全面解析【进阶 4 期】 深浅拷贝原理【进阶 5 期】 原型 Prototype【进阶 6 期】 高阶函数【进阶 7 期】 事件机制【进阶 8 期】 Event Loop 原理【进阶 9 期】 Promise 原理【进阶 10 期】Async/Await 原理【进阶 11 期】防抖/节流原理【进阶 12 期】模块化详解【进阶 13 期】ES6 重难点【进阶 14 期】计算机网络概述【进阶 15 期】浏览器渲染原理【进阶 16 期】webpack 配置【进阶 17 期】webpack 原理【进阶 18 期】前端监控【进阶 19 期】跨域和安全【进阶 20 期】性能优化【进阶 21 期】VirtualDom 原理【进阶 22 期】Diff 算法【进阶 23 期】MVVM 双向绑定【进阶 24 期】Vuex 原理【进阶 25 期】Redux 原理【进阶 26 期】路由原理【进阶 27 期】VueRouter 源码解析【进阶 28 期】ReactRouter 源码解析 --></p>]]></content>
      
      
      <categories>
          
          <category> MarkDown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
